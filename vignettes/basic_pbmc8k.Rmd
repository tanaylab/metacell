---
title: "Running metacell analysis: vanilla pipeline"
author: "A Tanay"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Running metacell analysis: vanilla pipeline}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The metacell package allow import and manipulations of single cell RNA-seq count matrices, gene feature analysis, modeling similarities and inference of a metacell model. In this note we exemplify basic metacell use using the small 8.5k PBMC data from the 10x system.

We start by loading the library:

```{r, eval=TRUE, warning=FALSE}
library("metacell")
```

To start using metacell, you first initialize a database. This is not much more than linking the package to directory that store all your objects. In our case we will initialize the DB to the testdb directory:

```{r, eval=TRUE, warning=FALSE}
if(!dir.exists("testdb")) dir.create("testdb/")
scdb_init("testdb/", force_reinit=T)
```

force_reinit=T instruct the system to override existing db objects. This can be important if you are running in cycles and want to update your objects. Otherwise, the scdb object reuse loaded objects to save time on reading and initializing them from the disk.

Let's load a matrix to the system. We'll do a simple import for a 10x dataset, which is stored in the package datain directory, using a sparse matrix format generated by the 10x pipeline:

```{r, eval=TRUE, warning=FALSE}
mcell_import_scmat_10x("test", base_dir="http://www.wisdom.weizmann.ac.il/~atanay/metac_data/pbmc_8k/")
mat = scdb_mat("test")
print(dim(mat@mat))
```

The _scdb_mat()_ command is returning a matrix object, which has one slot containing the count matrix - mat@mat, as well as additional features we will mention below.

Before starting to analyze the data, we link the package to a figure directory:

```{r, eval=TRUE, warning=FALSE}
if(!dir.exists("figs")) dir.create("figs/")
scfigs_init("figs/")
```

meta cell uses a standardized naming scheme fro the figures, to make it easier to archive and link analysis figures to the db objects. In principles, figures in the figures directory are named after the object data type they refer to (for example, mat for matrices, mc for metacells, and more, see below). The figure name then include also the object name they refer to, and a suffix describing the actual figure type.

To get a basic understanding of the new data, we will plot the distribution of umi count per cell:

```{r, eval=TRUE, warning=FALSE}
mcell_plot_umis_per_cell("test")
```
![Umi distribution plot](figs/test.total_umi_distr.png)

Umi distributions seems fine (so we don't have major errors in importing). We want to clean some known issues from the matrix before starting to work with it. We generate a list of mitochondrial genes that typically mark cells as being stressed or dying, as well as IG genes that can represent strong clonal signatures in plasma cells, rather than cellular identity.

```{r, eval=TRUE, warning=FALSE}
mat = scdb_mat("test")
nms = c(rownames(mat@mat), rownames(mat@ignore_gmat))
ig_genes = c(grep("^IGJ", nms, v=T), 
				grep("^IGH",nms,v=T),
				grep("^IGK", nms, v=T), 
				grep("^IGL", nms, v=T))

bad_genes = unique(c(grep("^MT-", nms, v=T), grep("^MTMR", nms, v=T), grep("^MTND", nms, v=T),"NEAT1","TMSB4X", "TMSB10", ig_genes))

bad_genes
```

We wil next ask the package to ignore the genes in the matrix:

```{r, eval=TRUE, warning=FALSE}
mcell_mat_ignore_genes(new_mat_id="test", mat_id="test", bad_genes, reverse=F) 
```

Ignored genes are kept in the matrix for reference, but all downstream analysis will disregard them. It means that cells with more or less Umis for these genes will not be distinguishable (unless other correlated genes are still kept in the matrix).

We will also eliminate in this case small cells, based on examination of the umi distribution. We can iteratively modify our filtering decisions given results of the downstream analysis:

```{r, eval=TRUE, warning=FALSE}
mcell_mat_ignore_small_cells("test", "test", 800)
```

We will move on to compute statistics on the distributions of each gene in the data, which is going to be our main tool for selecting informative genes for metacell analysis:

```{r, eval=TRUE, warning=FALSE}
mcell_add_gene_stat(gstat_id="test", mat_id="test", force=T)
```

This generates a new object of type gstat under the name "test", by analyzing the count matrix with id "test". We can dive into observation of interesting genes and their distributions, or move directly to select a gene set for downstream analysis. For now, let's to the latter. 

We create a new object of type gene set, to which all genes that have scaled variance (variance divided by mean) over a given threshold are added:

```{r, eval=TRUE, warning=FALSE}
mcell_gset_filter_varmean(gset_id="test_feats", gstat_id="test", T_vm=0.08, force_new=T)
mcell_gset_filter_cov(gset_id = "test_feats", gstat_id="test", T_tot=100, T_top3=2)
```

The first command create a new gene set with all genes for which the scaled variance is 0.08 and higher. The second command restrict this gene set to genes with at least 100 UMI across the entire dataset, and also require selected genes to have at least three cells for which 3 or more UMIs were recorded.

We can refine our parameters by plotting all genes and our selected gene set given the mean and variance statistics:

```{r, eval=TRUE, warning=FALSE}
mcell_plot_gstats(gstat_id="test", gset_id="test_feats")
```
![var mean plot](figs/test.varmin.png)

Assuming we are happy with the selected genes (some strategies for studying them will be discussed in another vignette), we will move forward to create a similarity graph (cgraph), using a construction called balanced knn graph:

```{r, eval=TRUE, warning=FALSE}
mcell_add_cgraph_from_mat_bknn(mat_id="test", 
				gset_id = "test_feats", 
				graph_id="test_graph",
				K=100,
				dsamp=T)
```

This add to the db a new cell graph object named test_graph. the K=100 parameter is important, it defines the initial attempt of the system to assign neighbors for each cell and ultimately can affect the size distribution of derived metacells. Note that constructing the graph can become computationally intensive if going beyond 20-30,000 cells. The system is currently limited by memory, and we have generated graph on 160,000 cells on machines with 0.5TB RAM. For more modest datasets (e.g. few 10x lanes or MARS-seq experiments), things will run very quickly.

The next step will use the cgraph to sample five hundred metacell covers, each organizing 75% of the cells into groups that are coherent (have high edge density) in the graph.

```{r, eval=TRUE, warning=FALSE}
mcell_coclust_from_graph_resamp(
				coc_id="test_coc500", 
				graph_id="test_graph",
				min_mc_size=20, 
				p_resamp=0.75, n_resamp=500)
```

The typical size distribution of the resampled metacells will be largely determined by the K parameter used for computing the cgraph. The resampling process may take a while if the graphs are very large. You can modify n_resamp to generate fewer resamples.

The resampling procedures crate a new object in the database named _test_coc500_, and storing the number of times each pair of cells end up being part of the same metacells. This can be used to generate a new similarity graph, which allow much better accuracy in calling the final set of metacells:

```{r, eval=TRUE, warning=FALSE}
mcell_mc_from_coclust_balanced(
				coc_id="test_coc500", 
				mat_id= "test",
				mc_id= "test_mc", 
				K=30, min_mc_size=30, alpha=2)
```

We created a metacell object _test_mc_, based on analysis of the coclustring graph. The parameter K determine the number of neighbors we wish to minimally associate with each cell. Alpha=2 is defining how harsh the filtering of co-cluster edges will be prior to running the metacell cover on them - e.g. alpha=2 will eliminate co-cluster relationships whenever one of the neighboring cells have K partners with more than twice as many co-cluster relationships.

We now have a preliminary metacell object, but it is good practice to make sure all metacells within it are homogeneous. This is done by the outlier scan procedure, which attempt splitting metacells (if their underlying similarity structure allows it), and remove outliers cells whenever there is evidence for a single gene expressed in them much stronger than anticipated from the metacell collective behavior.

```{r, eval=TRUE, warning=FALSE}
mcell_plot_outlier_heatmap(mc_id="test_mc", mat_id = "test", T_lfc=3)
mcell_mc_split_filt(new_mc_id="test_mc_f", 
			mc_id="test_mc", 
			mat_id="test",
			T_lfc=3, plot_mats=F)
```

The first command generate a heat map summarizing the detected outlier behaviors. This is possible only for dataset with modest size.

![outliers fig](figs/test_mc.outlier.png)

The filtered metacell object _test_mc_f_ can now be visualized. In order to do this effectively, we usually go through one or two iterations of selecting informative marker genes. The package can select markers for you automatically - by simply looking for genes that are strongly enriched in any of the metacells:

```{r, eval=TRUE, warning=FALSE}
mcell_gset_from_mc_markers(gset_id="test_markers", mc_id="test_mc_f")
```

It is however very useful to go and analyze metacell models in depth, and select genes with known or hypothesized biological significance. We will assign each of these genes with a color, fold change threshold and priority, using a table that look like this:

group |gene |color |priority | T_fold
----|----|---|---|---  
NK | CLIC3 | brown | 4 | 8
NK_KLRF1 | KLRF1 | chocolate3 | 8 | 3
CD8 | CD8B | yellow | 5 | 2
T+GMZK | GZMK | sienna1 | 5 | 4
Mk+COMP | C1QA | darkolivegreen | 5 | 2
S100A9 | S100A9 | darkseagreen3 | 5 | 20
LYZ | LYZ | chartreuse | 4 | 8
B | CD79B | lightblue | 4 | 4
MZB1 | MZB1 | cyan | 5 | 4
IRF8 | IRF8 | cyan2 | 5 | 4
IL7R | IL7R | navajowhite2 | 3 | 2
Treg | FOXP3 | magenta | 5 | 1.5
CD3 | CD3G | lemonchiffon | 1 | 0.7

Applying this table to color metacell is done using the command mc_colorize as shown below. Note that there are more sophisticated ways to color/annotate metacells, and that ultimately there is no substitute to look at gene distributions and read literature about possible functions and regulatory mechanisms.

```{r, eval=TRUE, warning=FALSE}
marks_colors = read.table(system.file("extdata", "pbmc_mc_colorize.txt", package="metacell"), sep="\t", h=T, stringsAsFactors=F)
mc_colorize("test_mc_f", marker_colors=marks_colors)
```
We are now equipped with some basic coloring of metacells, which BTW we can access directly:

```{r, eval=TRUE, warning=FALSE}
mc = scdb_mc("test_mc_f")
table(mc@colors)
```
Or we can use the color to produce a labeled heat map, showing selected genes and their distributions over metacells, with the colored annotation shown at the bottom:

```{r, eval=TRUE, warning=FALSE}
mcell_mc_plot_marks(mc_id="test_mc_f", gset_id="test_markers", mat_id="test")
```
![heatmap_marks](figs/test_mc_f.cells_heat_marks.png)

Note that the values plotted are color coded log2(fold enrichmnet) value of the metacell over the median of all other metacells. It can be useful to explore these values directly - e.g.:

```{r, eval=TRUE, warning=FALSE}
lfp = log2(mc@mc_fp)
tail(sort(lfp["CD8A",]))
```

Heat maps are useful, but sometime hard to interpret, and so we can add to these visualizations that try to explore the similarity structure among metacells (or among cells within metacells). For this we construct a 2D projection, and use it to plot cells and metacell, as well as their key similarities which will be shown as edges connecting metacells. This plot will use the same metacell coloring we established before (and if we will improve it based on additional analysis, this plot can be regenerated): 

```{r, eval=TRUE, warning=FALSE}
mcell_mc2d_force_knn(mc2d_id="test_2dproj",mc_id="test_mc_f", graph_id="test_graph")
tgconfig::set_param("mcell_mc2d_height",1000, "metacell")
tgconfig::set_param("mcell_mc2d_width",1000, "metacell")
mcell_mc2d_plot(mc2d_id="test_2dproj")
```

Note that we changed the metacell parameters "mcell_mc2d_height/width" to get a reasonably size figure. There are many additional parameters that can be tuned in metacell, some of these will be discussed elsewhere, while other will remain burried in the code and are not meant for routine tuning. We get the following figure:

![proj2d mean plot](figs/test_2dproj.2d_proj.png)

(you don't have to complete the following optional stage of the pipeline). While 2D projections are very popular and intiutive (and also misleading) ways to visualize scRNA-seq results, we can also summarize the similarity structure among metacells using a "confusion matrix" which summarize all similairities between metacells, including those that are used as edges in the 2D projection, and those that are not. This can provide sometime ways to capture hierarchical structure or other complex organization among metacells. 

We first create a hierarchical clustering of metacells, based on the number of similairity relations between their cells:

```{r, eval=TRUE, warning=FALSE}
mc_hc = mcell_mc_hclust_confu(mc_id="test_mc_f", 
											graph_id="test_graph")
```

Now we generate clusters of metacells (based on their hierarchy, and we visualize the confusion matrix and these clusters):

```{r, eval=TRUE, warning=FALSE}
mc_sup = mcell_mc_hierarchy(mc_id="test_mc_f",
													mc_hc=mc_hc, T_gap=0.04)
mcell_mc_plot_hierarchy(mc_id="test_mc_f", 
				   graph_id="test_graph", 
					mc_order=mc_hc$order, 
					sup_mc = mc_sup, 
					width=1400, heigh=1000, min_nmc=2)
```

![confusion matrix](figs/pbmc_8k_bs500fd.supmc_confu.png)
